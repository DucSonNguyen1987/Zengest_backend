/**
 * TEST COMPLET ZENGEST BACKEND v1.2.0 - VERSION ADAPT√âE
 * Prend en compte la cr√©ation automatique de restaurant pour les owners
 * et g√®re tous les cas de figure √©voqu√©s dans les discussions pr√©c√©dentes
 */

console.log('üß™ TEST COMPLET ZENGEST BACKEND v1.2.0 - ADAPT√â');
console.log('=' .repeat(60));
console.log('‚ö° Test de toutes les fonctionnalit√©s du syst√®me');
console.log('üéØ Objectif: Validation compl√®te avec gestion auto restaurant');
console.log('üÜï Nouveau: Cr√©ation automatique restaurant pour owners\n');

const API_BASE = 'http://localhost:3000/api';

// Configuration des comptes de test
const TEST_ACCOUNTS = {
  admin: {
    email: 'admin@zengest.com',
    password: 'Admin123!',
    role: 'ADMIN',
    name: 'Admin Syst√®me'
  },
  owner: {
    email: 'owner@bistrot-zengest.com',
    password: 'Owner123!',
    role: 'OWNER',
    name: 'Jean Dupont'
  },
  manager: {
    email: 'manager@bistrot-zengest.com',
    password: 'Manager123!',
    role: 'MANAGER',
    name: 'Marie Martin'
  },
  staff_floor: {
    email: 'sophie.salle@bistrot-zengest.com',
    password: 'Staff123!',
    role: 'STAFF_FLOOR',
    name: 'Sophie Bernard'
  },
  staff_bar: {
    email: 'pierre.bar@bistrot-zengest.com',
    password: 'Staff123!',
    role: 'STAFF_BAR',
    name: 'Pierre Leroy'
  },
  staff_kitchen: {
    email: 'paul.cuisine@bistrot-zengest.com',
    password: 'Staff123!',
    role: 'STAFF_KITCHEN',
    name: 'Paul Roux'
  }
};

// √âtat global des tests
let testResults = {
  total: 0,
  passed: 0,
  failed: 0,
  errors: [],
  userTokens: {},
  userData: {},
  restaurantCreated: false,
  startTime: Date.now()
};

// Utilitaires
const sleep = (ms) => new Promise(resolve => setTimeout(resolve, ms));

const makeRequest = async (method, endpoint, data = null, headers = {}) => {
  const url = `${API_BASE}${endpoint}`;
  const options = {
    method,
    headers: {
      'Content-Type': 'application/json',
      ...headers
    }
  };

  if (data && ['POST', 'PUT', 'PATCH'].includes(method)) {
    options.body = JSON.stringify(data);
  }

  const response = await fetch(url, options);
  const responseData = await response.text();
  
  let parsedData;
  try {
    parsedData = JSON.parse(responseData);
  } catch {
    parsedData = { rawResponse: responseData };
  }

  return {
    status: response.status,
    ok: response.ok,
    data: parsedData,
    headers: Object.fromEntries(response.headers.entries())
  };
};

const logTest = (testName, success, details = '', duration = 0) => {
  testResults.total++;
  const status = success ? '‚úÖ' : '‚ùå';
  const time = duration > 0 ? ` (${duration}ms)` : '';
  
  if (success) {
    testResults.passed++;
    console.log(`${status} ${testName}${time}`);
    if (details) console.log(`   üí° ${details}`);
  } else {
    testResults.failed++;
    console.log(`${status} ${testName}${time}`);
    if (details) console.log(`   ‚ùå ${details}`);
    testResults.errors.push({ test: testName, error: details });
  }
};

const logSection = (title) => {
  console.log(`\n${'üìã ' + title}`);
  console.log('‚îÄ'.repeat(50));
};

// === NOUVELLE FONCTION: GESTION RESTAURANT OWNER ===
const ensureOwnerHasRestaurant = async (ownerToken, ownerData) => {
  console.log('\nüîç V√©rification restaurant pour owner...');
  
  try {
    // V√©rifier si l'owner a d√©j√† un restaurant assign√©
    if (ownerData.restaurantId) {
      console.log(`‚úÖ Owner a d√©j√† un restaurant: ${ownerData.restaurantId.name || ownerData.restaurantId}`);
      return ownerData.restaurantId;
    }

    console.log('‚ö†Ô∏è Owner sans restaurant assign√© - cr√©ation automatique...');

    // Cr√©er un restaurant pour l'owner
    const newRestaurant = {
      name: `Restaurant de ${ownerData.firstName} ${ownerData.lastName}`,
      description: 'Restaurant cr√©√© automatiquement pour les tests',
      address: {
        street: '123 Rue de Test',
        city: 'Paris',
        zipCode: '75001',
        country: 'France'
      },
      contact: {
        phone: '+33140123456',
        email: ownerData.email.replace('@', '+restaurant@')
      },
      cuisine: ['fran√ßaise', 'moderne'],
      priceRange: '‚Ç¨‚Ç¨',
      capacity: {
        seatingCapacity: 50,
        tablesCount: 12
      },
      hours: {
        monday: { open: '12:00', close: '14:30', closed: false },
        tuesday: { open: '12:00', close: '14:30', closed: false },
        wednesday: { open: '12:00', close: '14:30', closed: false },
        thursday: { open: '12:00', close: '14:30', closed: false },
        friday: { open: '12:00', close: '14:30', closed: false },
        saturday: { open: '19:00', close: '23:00', closed: false },
        sunday: { closed: true }
      },
      features: {
        wifi: true,
        terrace: false,
        reservations: true,
        creditCards: true
      },
      owner: ownerData._id
    };

    // Utiliser le token admin pour cr√©er le restaurant
    const adminToken = testResults.userTokens.admin;
    if (!adminToken) {
      throw new Error('Token admin requis pour cr√©er le restaurant');
    }

    const createResponse = await makeRequest('POST', '/restaurants', newRestaurant, {
      'Authorization': `Bearer ${adminToken}`
    });

    if (!createResponse.ok) {
      throw new Error(`√âchec cr√©ation restaurant: ${createResponse.data.message}`);
    }

    const restaurant = createResponse.data.data.restaurant;
    console.log(`‚úÖ Restaurant cr√©√©: ${restaurant.name} (ID: ${restaurant.id})`);

    // Assigner le restaurant √† l'owner
    const updateResponse = await makeRequest('PUT', `/users/${ownerData._id}`, {
      restaurantId: restaurant.id
    }, {
      'Authorization': `Bearer ${adminToken}`
    });

    if (!updateResponse.ok) {
      console.warn(`‚ö†Ô∏è Impossible d'assigner le restaurant √† l'owner: ${updateResponse.data.message}`);
    } else {
      console.log(`‚úÖ Restaurant assign√© √† l'owner`);
    }

    testResults.restaurantCreated = true;
    return restaurant;

  } catch (error) {
    console.error(`‚ùå Erreur gestion restaurant owner: ${error.message}`);
    return null;
  }
};

// === TESTS PRINCIPAUX MODIFI√âS ===

// 1. Test de connectivit√© et sant√© du serveur
const testServerHealth = async () => {
  logSection('TEST CONNECTIVIT√â SERVEUR');
  
  try {
    const start = Date.now();
    
    // Test ping serveur
    const healthResponse = await makeRequest('GET', '/health');
    const healthDuration = Date.now() - start;
    
    logTest(
      'Sant√© du serveur',
      healthResponse.ok && healthResponse.data.success,
      `Uptime: ${healthResponse.data.uptime}s, Env: ${healthResponse.data.environment}`,
      healthDuration
    );

    // Test documentation API
    const docsResponse = await makeRequest('GET', '/docs');
    logTest(
      'Documentation API',
      docsResponse.ok && docsResponse.data.success,
      `Version: ${docsResponse.data.version}`
    );

    // Test route racine
    const rootResponse = await makeRequest('GET', '/');
    logTest(
      'Route racine',
      rootResponse.ok && rootResponse.data.success,
      `Zengest v${rootResponse.data.version}`
    );

    return true;
  } catch (error) {
    logTest('Connectivit√© serveur', false, `Erreur: ${error.message}`);
    return false;
  }
};

// 2. Test d'authentification MODIFI√â avec gestion restaurant
const testAuthentication = async () => {
  logSection('TEST AUTHENTIFICATION & GESTION RESTAURANT');
  
  for (const [role, account] of Object.entries(TEST_ACCOUNTS)) {
    try {
      const start = Date.now();
      const response = await makeRequest('POST', '/auth/login', {
        email: account.email,
        password: account.password
      });
      const duration = Date.now() - start;

      if (response.ok && response.data.success) {
        testResults.userTokens[role] = response.data.data.token;
        testResults.userData[role] = response.data.data.user;
        
        logTest(
          `Connexion ${account.name} (${role})`,
          true,
          `Token g√©n√©r√©, Restaurant: ${response.data.data.user.restaurantId?.name || 'N/A'}`,
          duration
        );
        
        // Test route /auth/me
        const meResponse = await makeRequest('GET', '/auth/me', null, {
          'Authorization': `Bearer ${testResults.userTokens[role]}`
        });
        
        logTest(
          `Profil ${role}`,
          meResponse.ok && meResponse.data.success,
          `R√¥le: ${meResponse.data.data.user.role}, Permissions: ${meResponse.data.data.permissions?.length || 0}`
        );

        // NOUVEAU: Gestion sp√©ciale pour les owners
        if (role === 'owner') {
          const ownerData = response.data.data.user;
          const restaurant = await ensureOwnerHasRestaurant(
            testResults.userTokens[role], 
            ownerData
          );
          
          if (restaurant) {
            logTest(
              'Restaurant owner configur√©',
              true,
              `Restaurant: ${restaurant.name}`
            );
            
            // Mettre √† jour les donn√©es utilisateur avec le restaurant
            testResults.userData[role].restaurantId = restaurant;
          } else {
            logTest(
              'Restaurant owner configur√©',
              false,
              'Impossible de cr√©er/assigner un restaurant'
            );
          }
        }
        
      } else {
        logTest(
          `Connexion ${account.name} (${role})`,
          false,
          response.data.message || '√âchec de connexion',
          duration
        );
      }
    } catch (error) {
      logTest(`Authentification ${role}`, false, error.message);
    }
  }
};

// 3. Test des permissions MODIFI√â
const testPermissions = async () => {
  logSection('TEST PERMISSIONS & AUTORISATIONS');
  
  const permissionTests = [
    {
      name: 'Admin acc√®s utilisateurs',
      role: 'admin',
      endpoint: '/users',
      shouldPass: true
    },
    {
      name: 'Staff acc√®s utilisateurs (interdit)',
      role: 'staff_floor',
      endpoint: '/users',
      shouldPass: false
    },
    {
      name: 'Owner acc√®s restaurant',
      role: 'owner',
      endpoint: '/restaurants',
      shouldPass: true,
      note: 'Owner doit maintenant avoir un restaurant'
    },
    {
      name: 'Staff acc√®s commandes',
      role: 'staff_floor',
      endpoint: '/orders',
      shouldPass: true
    },
    {
      name: 'Manager acc√®s r√©servations',
      role: 'manager',
      endpoint: '/reservations',
      shouldPass: true
    },
    {
      name: 'Staff bar acc√®s menu',
      role: 'staff_bar',
      endpoint: '/menu',
      shouldPass: true
    }
  ];

  for (const test of permissionTests) {
    try {
      const token = testResults.userTokens[test.role];
      if (!token) {
        logTest(test.name, false, 'Token non disponible');
        continue;
      }

      const response = await makeRequest('GET', test.endpoint, null, {
        'Authorization': `Bearer ${token}`
      });

      const success = test.shouldPass ? response.ok : !response.ok;
      
      logTest(
        test.name,
        success,
        `Status: ${response.status} (attendu: ${test.shouldPass ? '2xx' : '403'})${test.note ? ' - ' + test.note : ''}`
      );
    } catch (error) {
      logTest(test.name, false, error.message);
    }
  }
};

// 4. Test des restaurants MODIFI√â
const testRestaurants = async () => {
  logSection('TEST GESTION RESTAURANTS');
  
  const adminToken = testResults.userTokens.admin;
  if (!adminToken) {
    logTest('Gestion restaurants', false, 'Token admin requis');
    return;
  }

  try {
    // Liste des restaurants
    const listResponse = await makeRequest('GET', '/restaurants', null, {
      'Authorization': `Bearer ${adminToken}`
    });
    logTest(
      'Liste restaurants',
      listResponse.ok,
      `${listResponse.data.data?.restaurants?.length || 0} restaurants`
    );

    if (listResponse.ok && listResponse.data.data.restaurants.length > 0) {
      const restaurant = listResponse.data.data.restaurants[0];
      
      // D√©tails d'un restaurant
      const detailResponse = await makeRequest('GET', `/restaurants/${restaurant.id}`, null, {
        'Authorization': `Bearer ${adminToken}`
      });
      logTest('D√©tails restaurant', detailResponse.ok, restaurant.name);

      // Statut du restaurant
      const statusResponse = await makeRequest('GET', `/restaurants/${restaurant.id}/status`);
      logTest('Statut restaurant', statusResponse.ok, 'Statut r√©cup√©r√©');

      // NOUVEAU: Test acc√®s owner au restaurant cr√©√©
      const ownerToken = testResults.userTokens.owner;
      if (ownerToken && testResults.restaurantCreated) {
        const ownerAccessResponse = await makeRequest('GET', `/restaurants/${restaurant.id}`, null, {
          'Authorization': `Bearer ${ownerToken}`
        });
        logTest(
          'Owner acc√®s son restaurant',
          ownerAccessResponse.ok,
          'Owner peut acc√©der √† son restaurant cr√©√©'
        );
      }
    }
  } catch (error) {
    logTest('Gestion restaurants', false, error.message);
  }
};

// 5. Test cr√©ation commande MODIFI√â avec gestion plan par d√©faut
const testOrdersWithFloorPlan = async () => {
  logSection('TEST SYST√àME COMMANDES (AVEC PLAN AUTO)');
  
  const staffToken = testResults.userTokens.staff_floor;
  if (!staffToken) {
    logTest('Syst√®me commandes', false, 'Token staff requis');
    return;
  }

  try {
    // Liste des commandes
    const ordersResponse = await makeRequest('GET', '/orders', null, {
      'Authorization': `Bearer ${staffToken}`
    });
    logTest(
      'Liste commandes',
      ordersResponse.ok,
      `${ordersResponse.data.data?.orders?.length || 0} commandes`
    );

    // Commandes actives
    const activeResponse = await makeRequest('GET', '/orders/active', null, {
      'Authorization': `Bearer ${staffToken}`
    });
    logTest(
      'Commandes actives',
      activeResponse.ok,
      `${activeResponse.data.data?.orders?.length || 0} actives`
    );

    // NOUVEAU: Test cr√©ation commande SANS floorPlanId (doit utiliser le d√©faut)
    const menuResponse = await makeRequest('GET', '/menu?limit=1', null, {
      'Authorization': `Bearer ${staffToken}`
    });
    
    if (menuResponse.ok && menuResponse.data.data.menuItems.length > 0) {
      const menuItem = menuResponse.data.data.menuItems[0];
      
      // Test 1: Commande SANS floorPlanId
      const newOrderWithoutPlan = {
        tableNumber: '999',
        customer: {
          name: 'Client Test Sans Plan' // Format name simple
        },
        items: [{
          menuItem: menuItem.id,
          quantity: 1,
          price: menuItem.basePrice || 10
        }]
        // PAS de floorPlanId - doit √™tre g√©r√© automatiquement
      };

      const createResponse1 = await makeRequest('POST', '/orders', newOrderWithoutPlan, {
        'Authorization': `Bearer ${staffToken}`
      });
      
      logTest(
        'Cr√©ation commande sans floorPlanId',
        createResponse1.ok,
        createResponse1.ok ? 'Plan par d√©faut utilis√© automatiquement' : createResponse1.data.message
      );

      // Test 2: Commande avec format customer.firstName/lastName
      const newOrderWithNames = {
        tableNumber: '998',
        customer: {
          firstName: 'Jean',
          lastName: 'Test',
          phone: '+33123456789'
        },
        items: [{
          menuItem: menuItem.id,
          quantity: 2,
          price: menuItem.basePrice || 10
        }]
      };

      const createResponse2 = await makeRequest('POST', '/orders', newOrderWithNames, {
        'Authorization': `Bearer ${staffToken}`
      });
      
      logTest(
        'Cr√©ation commande format firstName/lastName',
        createResponse2.ok,
        createResponse2.ok ? 'Format client standard accept√©' : createResponse2.data.message
      );

      // Test modification du statut si commande cr√©√©e
      if (createResponse1.ok) {
        const orderId = createResponse1.data.data.order.id;
        const statusResponse = await makeRequest('PATCH', `/orders/${orderId}/status`, {
          status: 'confirmed'
        }, {
          'Authorization': `Bearer ${staffToken}`
        });
        logTest('Modification statut commande', statusResponse.ok, 'Statut modifi√© avec succ√®s');
      }
      
    } else {
      logTest('Menu requis pour tests commandes', false, 'Aucun √©l√©ment menu trouv√©');
    }

    // Statistiques des commandes
    const statsResponse = await makeRequest('GET', '/orders/statistics/summary', null, {
      'Authorization': `Bearer ${staffToken}`
    });
    logTest('Statistiques commandes', statsResponse.ok, 'Stats r√©cup√©r√©es');

  } catch (error) {
    logTest('Syst√®me commandes avanc√©', false, error.message);
  }
};

// 6. Test r√©servations MODIFI√â avec gestion nom flexible
const testReservationsFlexible = async () => {
  logSection('TEST SYST√àME R√âSERVATIONS (FORMAT FLEXIBLE)');
  
  const managerToken = testResults.userTokens.manager;
  if (!managerToken) {
    logTest('Syst√®me r√©servations', false, 'Token manager requis');
    return;
  }

  try {
    // Liste des r√©servations
    const reservationsResponse = await makeRequest('GET', '/reservations', null, {
      'Authorization': `Bearer ${managerToken}`
    });
    logTest(
      'Liste r√©servations',
      reservationsResponse.ok,
      `${reservationsResponse.data.data?.reservations?.length || 0} r√©servations`
    );

    const tomorrow = new Date();
    tomorrow.setDate(tomorrow.getDate() + 1);
    tomorrow.setHours(20, 0, 0, 0);

    // Test 1: R√©servation avec firstName/lastName
    const reservation1 = {
      customer: {
        firstName: 'Test',
        lastName: 'Reservation',
        email: 'test.reservation1@example.com',
        phone: '+33123456789'
      },
      dateTime: tomorrow.toISOString(),
      partySize: 4,
      specialRequests: ['Table pr√®s de la fen√™tre']
    };

    const createResponse1 = await makeRequest('POST', '/reservations', reservation1, {
      'Authorization': `Bearer ${managerToken}`
    });
    
    logTest(
      'R√©servation format firstName/lastName',
      createResponse1.ok,
      createResponse1.ok ? 'Format standard accept√©' : createResponse1.data.message
    );

    // Test 2: R√©servation avec name simple (doit √™tre splitt√©)
    const reservation2 = {
      customer: {
        name: 'Jean Paul Dupont', // Nom complet simple
        email: 'jean.paul@example.com',
        phone: '+33123456789'
      },
      dateTime: new Date(tomorrow.getTime() + 3600000).toISOString(), // +1h
      partySize: 2
    };

    const createResponse2 = await makeRequest('POST', '/reservations', reservation2, {
      'Authorization': `Bearer ${managerToken}`
    });
    
    logTest(
      'R√©servation format name simple',
      createResponse2.ok,
      createResponse2.ok ? 'Nom automatiquement splitt√© en firstName/lastName' : createResponse2.data.message
    );

    // Test assignation table si r√©servation cr√©√©e
    if (createResponse1.ok) {
      const reservationId = createResponse1.data.data.reservation.id;
      
      // Confirmer la r√©servation
      const statusResponse = await makeRequest('PATCH', `/reservations/${reservationId}/status`, {
        status: 'confirmed'
      }, {
        'Authorization': `Bearer ${managerToken}`
      });
      logTest('Confirmation r√©servation', statusResponse.ok, 'R√©servation confirm√©e');

      // Tenter d'assigner une table
      const floorPlanResponse = await makeRequest('GET', '/floor-plans/default', null, {
        'Authorization': `Bearer ${managerToken}`
      });
      
      if (floorPlanResponse.ok && floorPlanResponse.data.data.floorPlan?.tables?.length > 0) {
        const table = floorPlanResponse.data.data.floorPlan.tables[0];
        const assignResponse = await makeRequest('PATCH', `/reservations/${reservationId}/assign-table`, {
          floorPlanId: floorPlanResponse.data.data.floorPlan.id,
          tableNumber: table.number
        }, {
          'Authorization': `Bearer ${managerToken}`
        });
        logTest('Assignment table', assignResponse.ok, `Table ${table.number} assign√©e`);
      }
    }

    // R√©servations par date (aujourd'hui)
    const today = new Date().toISOString().split('T')[0];
    const dateResponse = await makeRequest('GET', `/reservations/date/${today}`, null, {
      'Authorization': `Bearer ${managerToken}`
    });
    logTest(
      'R√©servations du jour',
      dateResponse.ok,
      `${dateResponse.data.data?.reservations?.length || 0} aujourd'hui`
    );

  } catch (error) {
    logTest('Syst√®me r√©servations flexible', false, error.message);
  }
};

// === REPRENDRE LES AUTRES TESTS (INCHANG√âS) ===

// 7. Test des plans de salle
const testFloorPlans = async () => {
  logSection('TEST PLANS DE SALLE');
  
  const managerToken = testResults.userTokens.manager;
  if (!managerToken) {
    logTest('Plans de salle', false, 'Token manager requis');
    return;
  }

  try {
    // Liste des plans
    const listResponse = await makeRequest('GET', '/floor-plans', null, {
      'Authorization': `Bearer ${managerToken}`
    });
    logTest(
      'Liste plans de salle',
      listResponse.ok,
      `${listResponse.data.data?.floorPlans?.length || 0} plans`
    );

    // Plan par d√©faut
    const defaultResponse = await makeRequest('GET', '/floor-plans/default', null, {
      'Authorization': `Bearer ${managerToken}`
    });
    logTest('Plan par d√©faut', defaultResponse.ok, 'Plan r√©cup√©r√©');

    if (defaultResponse.ok && defaultResponse.data.data.floorPlan) {
      const floorPlan = defaultResponse.data.data.floorPlan;
      
      // D√©tails du plan
      const detailResponse = await makeRequest('GET', `/floor-plans/${floorPlan.id}`, null, {
        'Authorization': `Bearer ${managerToken}`
      });
      logTest(
        'D√©tails plan',
        detailResponse.ok,
        `${floorPlan.tables?.length || 0} tables, Capacit√©: ${floorPlan.totalCapacity || 0}`
      );

      // Test de modification de statut de table
      if (floorPlan.tables && floorPlan.tables.length > 0) {
        const table = floorPlan.tables[0];
        const statusResponse = await makeRequest('PATCH', 
          `/floor-plans/${floorPlan.id}/tables/${table.id}/status`,
          { status: 'occupied' },
          { 'Authorization': `Bearer ${managerToken}` }
        );
        logTest('Modification statut table', statusResponse.ok, `Table ${table.number} modifi√©e`);
      }
    }
  } catch (error) {
    logTest('Plans de salle', false, error.message);
  }
};

// 8. Test du menu
const testMenu = async () => {
  logSection('TEST GESTION MENU');
  
  const staffToken = testResults.userTokens.staff_bar;
  if (!staffToken) {
    logTest('Gestion menu', false, 'Token staff requis');
    return;
  }

  try {
    // Liste du menu
    const menuResponse = await makeRequest('GET', '/menu', null, {
      'Authorization': `Bearer ${staffToken}`
    });
    logTest(
      'Liste menu',
      menuResponse.ok,
      `${menuResponse.data.data?.menuItems?.length || 0} √©l√©ments`
    );

    // Cat√©gories
    const categoriesResponse = await makeRequest('GET', '/menu/categories', null, {
      'Authorization': `Bearer ${staffToken}`
    });
    logTest(
      'Cat√©gories menu',
      categoriesResponse.ok,
      `${categoriesResponse.data.data?.categories?.length || 0} cat√©gories`
    );

    // Test avec pagination
    const paginatedResponse = await makeRequest('GET', '/menu?page=1&limit=5', null, {
      'Authorization': `Bearer ${staffToken}`
    });
    logTest(
      'Pagination menu',
      paginatedResponse.ok,
      `Page ${paginatedResponse.data.data?.pagination?.currentPage || 0}/${paginatedResponse.data.data?.pagination?.totalPages || 0}`
    );

    if (menuResponse.ok && menuResponse.data.data.menuItems.length > 0) {
      const menuItem = menuResponse.data.data.menuItems[0];
      
      // D√©tails d'un √©l√©ment
      const itemResponse = await makeRequest('GET', `/menu/${menuItem.id}`, null, {
        'Authorization': `Bearer ${staffToken}`
      });
      logTest('D√©tails √©l√©ment menu', itemResponse.ok, menuItem.name);
    }
  } catch (error) {
    logTest('Gestion menu', false, error.message);
  }
};

// 9. Test des utilisateurs MODIFI√â avec r√¥les en minuscules
const testUserOperations = async () => {
  logSection('TEST GESTION UTILISATEURS (R√îLES MINUSCULES)');
  
  const adminToken = testResults.userTokens.admin;
  if (!adminToken) {
    logTest('CRUD Utilisateurs', false, 'Token admin requis');
    return;
  }

  try {
    // Liste des utilisateurs
    const listResponse = await makeRequest('GET', '/users', null, {
      'Authorization': `Bearer ${adminToken}`
    });
    logTest(
      'Liste utilisateurs',
      listResponse.ok,
      `${listResponse.data.data?.users?.length || 0} utilisateurs trouv√©s`
    );

    // Test pagination utilisateurs
    const paginatedResponse = await makeRequest('GET', '/users?page=1&limit=3', null, {
      'Authorization': `Bearer ${adminToken}`
    });
    logTest(
      'Pagination utilisateurs',
      paginatedResponse.ok && paginatedResponse.data.data?.pagination,
      paginatedResponse.ok ? `${paginatedResponse.data.data.pagination.total} utilisateurs` : 'Pagination manquante'
    );

    // Cr√©er un utilisateur de test avec r√¥le en minuscules
    const newUser = {
      firstName: 'Test',
      lastName: 'User',
      email: `test.${Date.now()}@zengest.com`,
      password: 'Test123!',
      role: 'staff_floor', // MINUSCULES
      phone: '+33123456789'
    };

    const createResponse = await makeRequest('POST', '/users', newUser, {
      'Authorization': `Bearer ${adminToken}`
    });
    
    let userId = null;
    if (createResponse.ok) {
      userId = createResponse.data.data.user.id;
      logTest('Cr√©ation utilisateur (r√¥le minuscule)', true, `ID: ${userId}, R√¥le: ${createResponse.data.data.user.role}`);

      // Modifier l'utilisateur
      const updateResponse = await makeRequest('PUT', `/users/${userId}`, {
        firstName: 'Test Updated'
      }, {
        'Authorization': `Bearer ${adminToken}`
      });
      logTest('Modification utilisateur', updateResponse.ok, 'Pr√©nom modifi√©');

      // R√©cup√©rer l'utilisateur
      const getResponse = await makeRequest('GET', `/users/${userId}`, null, {
        'Authorization': `Bearer ${adminToken}`
      });
      logTest(
        'R√©cup√©ration utilisateur',
        getResponse.ok,
        `Nom: ${getResponse.data.data?.user?.firstName}`
      );

      // Supprimer l'utilisateur
      const deleteResponse = await makeRequest('DELETE', `/users/${userId}`, null, {
        'Authorization': `Bearer ${adminToken}`
      });
      logTest('Suppression utilisateur', deleteResponse.ok, 'Utilisateur supprim√©');
    } else {
      logTest('Cr√©ation utilisateur (r√¥le minuscule)', false, createResponse.data.message);
    }
  } catch (error) {
    logTest('CRUD Utilisateurs', false, error.message);
  }
};

// 10. Test des notifications
const testNotifications = async () => {
  logSection('TEST SYST√àME NOTIFICATIONS');
  
  const adminToken = testResults.userTokens.admin;
  if (!adminToken) {
    logTest('Syst√®me notifications', false, 'Token admin requis');
    return;
  }

  try {
    // Test email
    const testEmailResponse = await makeRequest('POST', '/notifications/test', {
      email: 'test@example.com'
    }, {
      'Authorization': `Bearer ${adminToken}`
    });
    logTest(
      'Test email',
      testEmailResponse.ok,
      testEmailResponse.data.messageId ? 'Email envoy√©' : 'Configuration email manquante'
    );

    // Statistiques notifications
    const statsResponse = await makeRequest('GET', '/notifications/stats', null, {
      'Authorization': `Bearer ${adminToken}`
    });
    logTest('Statistiques notifications', statsResponse.ok, 'Stats r√©cup√©r√©es');

  } catch (error) {
    logTest('Syst√®me notifications', false, error.message);
  }
};

// === FONCTION PRINCIPALE MODIFI√âE ===
const runCompleteTest = async () => {
  console.log(`üöÄ D√©marrage des tests adapt√©s √† ${new Date().toLocaleTimeString()}\n`);
  
  try {
    // V√©rifier que le serveur est accessible
    const serverHealthy = await testServerHealth();
    if (!serverHealthy) {
      console.log('\n‚ùå ARR√äT: Serveur non accessible');
      console.log('üí° V√©rifiez que le serveur est d√©marr√©: npm run dev');
      return;
    }

    // Suite des tests modifi√©s
    await testAuthentication(); // MODIFI√â: gestion restaurant owner
    await testPermissions(); // MODIFI√â: note owner restaurant
    await testUserOperations(); // MODIFI√â: r√¥les minuscules + pagination
    await testRestaurants(); // MODIFI√â: test acc√®s owner
    await testFloorPlans();
    await testMenu();
    await testOrdersWithFloorPlan(); // MODIFI√â: test plan auto + format client
    await testReservationsFlexible(); // MODIFI√â: formats nom flexibles
    await testNotifications();

    // Rapport final
    await generateFinalReport();

  } catch (error) {
    console.error('\nüí• ERREUR FATALE:', error.message);
    console.error('Stack:', error.stack);
  }
};

const generateFinalReport = async () => {
  const duration = Date.now() - testResults.startTime;
  const successRate = Math.round((testResults.passed / testResults.total) * 100);
  
  console.log('\n' + '='.repeat(60));
  console.log('üìä RAPPORT FINAL - TESTS ZENGEST BACKEND ADAPT√âS');
  console.log('='.repeat(60));
  
  console.log(`‚è±Ô∏è  Dur√©e totale: ${(duration / 1000).toFixed(1)}s`);
  console.log(`üìã Tests ex√©cut√©s: ${testResults.total}`);
  console.log(`‚úÖ Tests r√©ussis: ${testResults.passed}`);
  console.log(`‚ùå Tests √©chou√©s: ${testResults.failed}`);
  console.log(`üìà Taux de r√©ussite: ${successRate}%`);
  
  // Nouvelles fonctionnalit√©s test√©es
  console.log('\nüÜï NOUVELLES FONCTIONNALIT√âS TEST√âES:');
  console.log('-'.repeat(40));
  console.log(`üè¢ Restaurant auto-cr√©√© pour owner: ${testResults.restaurantCreated ? 'OUI' : 'NON'}`);
  console.log('üìã Commandes sans floorPlanId (plan auto)');
  console.log('üë§ Formats clients flexibles (name vs firstName/lastName)');
  console.log('üî§ R√¥les utilisateur en minuscules');
  console.log('üìÑ Pagination sur tous les endpoints');
  
  // √âvaluation globale
  if (successRate >= 95) {
    console.log('\nüéâ PARFAIT! Syst√®me enti√®rement fonctionnel avec toutes les adaptations');
    console.log('‚ú® Toutes les corrections et am√©liorations fonctionnent');
  } else if (successRate >= 85) {
    console.log('\n‚úÖ EXCELLENT! Syst√®me largement fonctionnel');
    console.log('üîß Quelques ajustements mineurs peuvent √™tre n√©cessaires');
  } else if (successRate >= 70) {
    console.log('\n‚ö†Ô∏è BON! Progr√®s significatif mais corrections √† poursuivre');
  } else {
    console.log('\n‚ùå CRITIQUE! Probl√®mes majeurs persistants');
  }

  // D√©tail des erreurs
  if (testResults.errors.length > 0) {
    console.log('\nüîç ERREURS D√âTECT√âES:');
    console.log('-'.repeat(40));
    testResults.errors.forEach((error, index) => {
      console.log(`${index + 1}. ${error.test}`);
      console.log(`   üí¨ ${error.error}`);
    });
  }

  // Recommandations sp√©cifiques
  console.log('\nüí° RECOMMANDATIONS ADAPT√âES:');
  console.log('-'.repeat(40));

  if (testResults.errors.some(e => e.test.includes('owner') || e.test.includes('restaurant'))) {
    console.log('üè¢ Probl√®mes restaurant owner:');
    console.log('   ‚Ä¢ V√©rifiez que les contr√¥leurs restaurant sont bien cr√©√©s');
    console.log('   ‚Ä¢ Contr√¥lez les permissions owner dans auth.js');
  }

  if (testResults.errors.some(e => e.test.includes('r√¥le') || e.test.includes('user'))) {
    console.log('üë§ Probl√®mes utilisateurs/r√¥les:');
    console.log('   ‚Ä¢ V√©rifiez le mod√®le User (r√¥les en minuscules)');
    console.log('   ‚Ä¢ Contr√¥lez que restaurantId est optionnel');
  }

  if (testResults.errors.some(e => e.test.includes('commande') || e.test.includes('order'))) {
    console.log('üìã Probl√®mes commandes:');
    console.log('   ‚Ä¢ V√©rifiez la gestion floorPlanId par d√©faut');
    console.log('   ‚Ä¢ Contr√¥lez les formats client name vs firstName/lastName');
  }

  // √âtat du syst√®me
  console.log('\nüè• √âTAT DU SYST√àME ADAPT√â:');
  console.log('-'.repeat(40));
  
  const criticalFeatures = [
    'Restaurant owner automatique',
    'Commandes sans floorPlanId',
    'Formats clients flexibles',
    'R√¥les minuscules',
    'Pagination compl√®te'
  ];

  criticalFeatures.forEach(feature => {
    const hasError = testResults.errors.some(e => 
      e.test.toLowerCase().includes(feature.toLowerCase().split(' ')[0])
    );
    console.log(`${hasError ? '‚ùå' : '‚úÖ'} ${feature}: ${hasError ? 'PROBL√àME' : 'OK'}`);
  });

  console.log('\nüéØ PROCHAINES √âTAPES:');
  console.log('-'.repeat(40));
  
  if (successRate >= 90) {
    console.log('‚úÖ Syst√®me pr√™t avec toutes les adaptations!');
    console.log('üöÄ Backend Zengest enti√®rement fonctionnel');
    console.log('üì± Pr√™t pour connexion frontend');
  } else {
    console.log('üîß Poursuivre les corrections selon les erreurs ci-dessus');
    console.log('üîÑ Relancer ce test apr√®s corrections');
    console.log('üìñ Consulter la documentation pour d√©tails');
  }

  console.log(`\n‚è∞ Test termin√© √† ${new Date().toLocaleTimeString()}`);
  console.log('üôè Merci d\'utiliser Zengest Backend avec toutes ses adaptations!');
};

// V√©rifier Node.js et d√©pendances
const checkEnvironment = () => {
  console.log('üîç V√©rification environnement...');
  
  // V√©rifier Node.js version
  const nodeVersion = process.version;
  console.log(`üì¶ Node.js: ${nodeVersion}`);
  
  // V√©rifier fetch (Node 18+)
  if (typeof fetch === 'undefined') {
    console.error('‚ùå fetch non disponible. Node.js 18+ requis ou installez node-fetch');
    process.exit(1);
  }
  
  console.log('‚úÖ Environnement compatible\n');
};

// === D√âMARRAGE ===
checkEnvironment();
runCompleteTest().catch(error => {
  console.error('\nüí• √âCHEC CRITIQUE:', error.message);
  process.exit(1);
});