
/**
 * CR√âATION DES CONTR√îLEURS MANQUANTS ZENGEST
 * G√©n√®re les contr√¥leurs userController.js et restaurantController.js
 * Avec toutes les m√©thodes n√©cessaires pour les tests
 */

const fs = require('fs');
const path = require('path');

console.log('üèóÔ∏è CR√âATION DES CONTR√îLEURS MANQUANTS');
console.log('='.repeat(50));
console.log('üéØ Objectif: Cr√©er les contr√¥leurs critiques manquants\n');

let filesCreated = 0;

// === UTILITAIRES ===
const ensureDirectory = (dirPath) => {
  if (!fs.existsSync(dirPath)) {
    fs.mkdirSync(dirPath, { recursive: true });
    console.log(`üìÅ Dossier cr√©√©: ${dirPath}`);
  }
};

const createFile = (filePath, content, description) => {
  try {
    fs.writeFileSync(filePath, content, 'utf8');
    console.log(`‚úÖ ${description} cr√©√©`);
    console.log(`üìç Chemin: ${filePath}`);
    filesCreated++;
    return true;
  } catch (error) {
    console.error(`‚ùå √âchec cr√©ation ${description}:`, error.message);
    return false;
  }
};

// === CONTR√îLEUR RESTAURANT ===
const createRestaurantController = () => {
  console.log('\nüè¢ 1. Cr√©ation restaurantController.js');
  
  const controllersDir = path.join(__dirname, 'src', 'controllers');
  ensureDirectory(controllersDir);
  
  const restaurantControllerPath = path.join(controllersDir, 'restaurantController.js');
  
  const restaurantControllerCode = `/**
 * CONTR√îLEUR RESTAURANT - G√©n√©r√© automatiquement
 * Gestion compl√®te des restaurants avec toutes les m√©thodes n√©cessaires
 */

const Restaurant = require('../models/Restaurant');
const User = require('../models/User');
const { createPagination } = require('../utils/pagination');

// === M√âTHODES PRINCIPALES ===

/**
 * R√©cup√©rer tous les restaurants
 * GET /restaurants
 */
exports.getAllRestaurants = async (req, res) => {
  try {
    console.log('getAllRestaurants appel√© par:', req.user?.email);
    
    const { page = 1, limit = 10, search, isActive } = req.query;
    
    // Construire le filtre
    const filter = {};
    if (isActive !== undefined) {
      filter.isActive = isActive === 'true';
    }
    if (search) {
      filter.$or = [
        { name: { $regex: search, $options: 'i' } },
        { 'address.city': { $regex: search, $options: 'i' } }
      ];
    }
    
    // V√©rification permissions
    if (req.user.role !== 'admin') {
      return res.status(403).json({
        success: false,
        message: 'Acc√®s non autoris√© - Admin requis'
      });
    }
    
    const pagination = createPagination(page, limit, 0);
    
    const restaurants = await Restaurant.find(filter)
      .populate('owner', 'firstName lastName email')
      .sort({ createdAt: -1 })
      .limit(pagination.limit)
      .skip(pagination.skip);
    
    const total = await Restaurant.countDocuments(filter);
    const finalPagination = createPagination(page, limit, total);
    
    console.log('Restaurants r√©cup√©r√©s:', { count: restaurants.length, total });
    
    res.json({
      success: true,
      data: {
        restaurants,
        pagination: finalPagination
      }
    });
    
  } catch (error) {
    console.error('Erreur getAllRestaurants:', error);
    res.status(500).json({
      success: false,
      message: 'Erreur lors de la r√©cup√©ration des restaurants',
      error: process.env.NODE_ENV === 'development' ? error.message : undefined
    });
  }
};

/**
 * R√©cup√©rer un restaurant par ID
 * GET /restaurants/:id
 */
exports.getRestaurant = async (req, res) => {
  try {
    const { id } = req.params;
    console.log('getRestaurant appel√© pour ID:', id, 'par:', req.user?.email);
    
    const restaurant = await Restaurant.findById(id)
      .populate('owner', 'firstName lastName email')
      .select('-__v');

    if (!restaurant) {
      console.log('Restaurant non trouv√© pour ID:', id);
      return res.status(404).json({
        success: false,
        message: 'Restaurant non trouv√©'
      });
    }

    // V√©rification permissions
    if (req.user.role !== 'admin' && 
        req.user.role !== 'owner' && 
        req.user.restaurantId?.toString() !== id) {
      console.log('Acc√®s refus√© pour utilisateur:', req.user.email, 'r√¥le:', req.user.role);
      return res.status(403).json({
        success: false,
        message: 'Acc√®s non autoris√© √† ce restaurant'
      });
    }

    console.log('Restaurant trouv√©:', restaurant.name);
    res.json({
      success: true,
      data: { restaurant }
    });
    
  } catch (error) {
    console.error('Erreur getRestaurant:', error);
    res.status(500).json({
      success: false,
      message: 'Erreur lors de la r√©cup√©ration du restaurant',
      error: process.env.NODE_ENV === 'development' ? error.message : undefined
    });
  }
};

/**
 * R√©cup√©rer le statut d'un restaurant
 * GET /restaurants/:id/status
 */
exports.getRestaurantStatus = async (req, res) => {
  try {
    const { id } = req.params;
    console.log('getRestaurantStatus appel√© pour ID:', id);
    
    const restaurant = await Restaurant.findById(id)
      .select('name isActive hours capacity features');

    if (!restaurant) {
      console.log('Restaurant non trouv√© pour statut, ID:', id);
      return res.status(404).json({
        success: false,
        message: 'Restaurant non trouv√©'
      });
    }

    // Calculer le statut en temps r√©el
    const now = new Date();
    const currentDay = now.toLocaleDateString('en-US', { weekday: 'lowercase' });
    const currentHour = now.getHours();
    const currentMinute = now.getMinutes();
    
    let isOpenNow = false;
    if (restaurant.hours && restaurant.hours[currentDay] && !restaurant.hours[currentDay].closed) {
      const openTime = restaurant.hours[currentDay].open || '00:00';
      const closeTime = restaurant.hours[currentDay].close || '23:59';
      
      const [openHour, openMin] = openTime.split(':').map(Number);
      const [closeHour, closeMin] = closeTime.split(':').map(Number);
      
      const currentTimeMinutes = currentHour * 60 + currentMinute;
      const openTimeMinutes = openHour * 60 + openMin;
      const closeTimeMinutes = closeHour * 60 + closeMin;
      
      isOpenNow = currentTimeMinutes >= openTimeMinutes && currentTimeMinutes < closeTimeMinutes;
    }

    console.log('Statut restaurant calcul√©:', { 
      name: restaurant.name,
      isActive: restaurant.isActive, 
      isOpenNow,
      currentDay,
      currentHour: \`\${currentHour}:\${currentMinute.toString().padStart(2, '0')}\`
    });
    
    res.json({
      success: true,
      data: {
        restaurant: {
          id: restaurant._id,
          name: restaurant.name,
          isActive: restaurant.isActive,
          isOpenNow,
          capacity: restaurant.capacity,
          features: restaurant.features,
          currentDay,
          currentTime: \`\${currentHour}:\${currentMinute.toString().padStart(2, '0')}\`,
          todayHours: restaurant.hours?.[currentDay] || { closed: true }
        }
      }
    });
    
  } catch (error) {
    console.error('Erreur getRestaurantStatus:', error);
    res.status(500).json({
      success: false,
      message: 'Erreur lors de la r√©cup√©ration du statut',
      error: process.env.NODE_ENV === 'development' ? error.message : undefined
    });
  }
};

/**
 * Cr√©er un nouveau restaurant
 * POST /restaurants
 */
exports.createRestaurant = async (req, res) => {
  try {
    console.log('createRestaurant appel√© par:', req.user?.email);
    
    // V√©rification permissions
    if (req.user.role !== 'admin') {
      return res.status(403).json({
        success: false,
        message: 'Acc√®s non autoris√© - Admin requis'
      });
    }
    
    const {
      name,
      description,
      address,
      contact,
      cuisine = [],
      priceRange = '‚Ç¨‚Ç¨',
      capacity,
      hours,
      features = {},
      owner
    } = req.body;
    
    // Validation
    if (!name || !address || !contact) {
      return res.status(400).json({
        success: false,
        message: 'Nom, adresse et contact sont requis'
      });
    }
    
    // V√©rifier que le propri√©taire existe
    if (owner) {
      const ownerUser = await User.findById(owner);
      if (!ownerUser) {
        return res.status(400).json({
          success: false,
          message: 'Propri√©taire sp√©cifi√© non trouv√©'
        });
      }
    }
    
    const newRestaurant = new Restaurant({
      name,
      description,
      address,
      contact,
      cuisine,
      priceRange,
      capacity,
      hours,
      features,
      owner: owner || req.user._id,
      isActive: true
    });
    
    const savedRestaurant = await newRestaurant.save();
    await savedRestaurant.populate('owner', 'firstName lastName email');
    
    console.log('Restaurant cr√©√©:', savedRestaurant.name, 'ID:', savedRestaurant._id);
    
    res.status(201).json({
      success: true,
      message: 'Restaurant cr√©√© avec succ√®s',
      data: { restaurant: savedRestaurant }
    });
    
  } catch (error) {
    console.error('Erreur createRestaurant:', error);
    res.status(500).json({
      success: false,
      message: 'Erreur lors de la cr√©ation du restaurant',
      error: process.env.NODE_ENV === 'development' ? error.message : undefined
    });
  }
};

/**
 * Mettre √† jour un restaurant
 * PUT /restaurants/:id
 */
exports.updateRestaurant = async (req, res) => {
  try {
    const { id } = req.params;
    console.log('updateRestaurant appel√© pour ID:', id, 'par:', req.user?.email);
    
    const restaurant = await Restaurant.findById(id);
    
    if (!restaurant) {
      return res.status(404).json({
        success: false,
        message: 'Restaurant non trouv√©'
      });
    }
    
    // V√©rification permissions
    if (req.user.role !== 'admin' && 
        (req.user.role !== 'owner' || req.user.restaurantId?.toString() !== id)) {
      return res.status(403).json({
        success: false,
        message: 'Acc√®s non autoris√©'
      });
    }
    
    const updateData = req.body;
    delete updateData._id;
    delete updateData.__v;
    
    const updatedRestaurant = await Restaurant.findByIdAndUpdate(
      id,
      updateData,
      { new: true, runValidators: true }
    ).populate('owner', 'firstName lastName email');
    
    console.log('Restaurant mis √† jour:', updatedRestaurant.name);
    
    res.json({
      success: true,
      message: 'Restaurant mis √† jour avec succ√®s',
      data: { restaurant: updatedRestaurant }
    });
    
  } catch (error) {
    console.error('Erreur updateRestaurant:', error);
    res.status(500).json({
      success: false,
      message: 'Erreur lors de la mise √† jour du restaurant',
      error: process.env.NODE_ENV === 'development' ? error.message : undefined
    });
  }
};

/**
 * Supprimer un restaurant
 * DELETE /restaurants/:id
 */
exports.deleteRestaurant = async (req, res) => {
  try {
    const { id } = req.params;
    console.log('deleteRestaurant appel√© pour ID:', id, 'par:', req.user?.email);
    
    // V√©rification permissions
    if (req.user.role !== 'admin') {
      return res.status(403).json({
        success: false,
        message: 'Acc√®s non autoris√© - Admin requis'
      });
    }
    
    const restaurant = await Restaurant.findById(id);
    
    if (!restaurant) {
      return res.status(404).json({
        success: false,
        message: 'Restaurant non trouv√©'
      });
    }
    
    await Restaurant.findByIdAndDelete(id);
    
    console.log('Restaurant supprim√©:', restaurant.name);
    
    res.json({
      success: true,
      message: 'Restaurant supprim√© avec succ√®s'
    });
    
  } catch (error) {
    console.error('Erreur deleteRestaurant:', error);
    res.status(500).json({
      success: false,
      message: 'Erreur lors de la suppression du restaurant',
      error: process.env.NODE_ENV === 'development' ? error.message : undefined
    });
  }
};

module.exports = exports;
`;

  createFile(restaurantControllerPath, restaurantControllerCode, 'RestaurantController');
};

// === CONTR√îLEUR USER ===
const createUserController = () => {
  console.log('\nüë• 2. Cr√©ation userController.js');
  
  const controllersDir = path.join(__dirname, 'src', 'controllers');
  ensureDirectory(controllersDir);
  
  const userControllerPath = path.join(controllersDir, 'userController.js');
  
  const userControllerCode = `/**
 * CONTR√îLEUR USER - G√©n√©r√© automatiquement  
 * Gestion compl√®te des utilisateurs avec pagination
 */

const User = require('../models/User');
const Restaurant = require('../models/Restaurant');
const bcrypt = require('bcryptjs');
const { createPagination } = require('../utils/pagination');

// === M√âTHODES PRINCIPALES ===

/**
 * R√©cup√©rer tous les utilisateurs
 * GET /users
 */
exports.getAllUsers = async (req, res) => {
  try {
    console.log('getAllUsers appel√© par:', req.user?.email, 'r√¥le:', req.user?.role);
    
    const { page = 1, limit = 10, role, search, restaurantId } = req.query;
    
    // V√©rification permissions
    if (!['admin', 'owner', 'manager'].includes(req.user.role)) {
      return res.status(403).json({
        success: false,
        message: 'Acc√®s non autoris√©'
      });
    }
    
    // Construire le filtre
    const filter = {};
    
    // Admin peut voir tous les utilisateurs
    // Owner/Manager ne voient que leur restaurant
    if (req.user.role === 'owner' || req.user.role === 'manager') {
      filter.restaurantId = req.user.restaurantId;
    }
    
    if (role && role !== 'all') {
      filter.role = role;
    }
    
    if (restaurantId && req.user.role === 'admin') {
      filter.restaurantId = restaurantId;
    }
    
    if (search) {
      filter.$or = [
        { firstName: { $regex: search, $options: 'i' } },
        { lastName: { $regex: search, $options: 'i' } },
        { email: { $regex: search, $options: 'i' } }
      ];
    }
    
    const pagination = createPagination(page, limit, 0);
    
    // Requ√™te avec pagination
    const users = await User.find(filter)
      .populate('restaurantId', 'name address.city')
      .select('-password -__v')
      .sort({ createdAt: -1 })
      .limit(pagination.limit)
      .skip(pagination.skip);
    
    const total = await User.countDocuments(filter);
    const finalPagination = createPagination(page, limit, total);
    
    console.log('Users r√©cup√©r√©s avec pagination:', { 
      count: users.length, 
      total, 
      page: finalPagination.currentPage,
      filter
    });
    
    res.json({
      success: true,
      data: {
        users,
        pagination: finalPagination
      }
    });
    
  } catch (error) {
    console.error('Erreur getAllUsers:', error);
    res.status(500).json({
      success: false,
      message: 'Erreur lors de la r√©cup√©ration des utilisateurs',
      error: process.env.NODE_ENV === 'development' ? error.message : undefined
    });
  }
};

/**
 * R√©cup√©rer un utilisateur par ID
 * GET /users/:id
 */
exports.getUser = async (req, res) => {
  try {
    const { id } = req.params;
    console.log('getUser appel√© pour ID:', id, 'par:', req.user?.email);
    
    const user = await User.findById(id)
      .populate('restaurantId', 'name address.city')
      .select('-password -__v');
    
    if (!user) {
      return res.status(404).json({
        success: false,
        message: 'Utilisateur non trouv√©'
      });
    }
    
    // V√©rification permissions
    const canAccess = req.user.role === 'admin' ||
                     (req.user.role === 'owner' && user.restaurantId?._id?.toString() === req.user.restaurantId?.toString()) ||
                     (req.user.role === 'manager' && user.restaurantId?._id?.toString() === req.user.restaurantId?.toString()) ||
                     (req.user._id.toString() === id);
    
    if (!canAccess) {
      return res.status(403).json({
        success: false,
        message: 'Acc√®s non autoris√©'
      });
    }
    
    console.log('User trouv√©:', user.email);
    
    res.json({
      success: true,
      data: { user }
    });
    
  } catch (error) {
    console.error('Erreur getUser:', error);
    res.status(500).json({
      success: false,
      message: 'Erreur lors de la r√©cup√©ration de l\\'utilisateur',
      error: process.env.NODE_ENV === 'development' ? error.message : undefined
    });
  }
};

/**
 * Cr√©er un utilisateur
 * POST /users
 */
exports.createUser = async (req, res) => {
  try {
    console.log('createUser appel√© par:', req.user?.email);
    
    // V√©rification permissions
    if (!['admin', 'owner'].includes(req.user.role)) {
      return res.status(403).json({
        success: false,
        message: 'Acc√®s non autoris√©'
      });
    }
    
    const {
      firstName,
      lastName,
      email,
      password,
      role,
      phone,
      restaurantId
    } = req.body;
    
    // Validation
    if (!firstName || !lastName || !email || !password || !role) {
      return res.status(400).json({
        success: false,
        message: 'Tous les champs obligatoires doivent √™tre remplis'
      });
    }
    
    // V√©rifier que l'email n'existe pas
    const existingUser = await User.findOne({ email });
    if (existingUser) {
      return res.status(400).json({
        success: false,
        message: 'Un utilisateur avec cet email existe d√©j√†'
      });
    }
    
    // Valider le r√¥le
    const validRoles = ['admin', 'owner', 'manager', 'staff_bar', 'staff_floor', 'staff_kitchen', 'guest'];
    if (!validRoles.includes(role)) {
      return res.status(400).json({
        success: false,
        message: \`R√¥le invalide. R√¥les autoris√©s: \${validRoles.join(', ')}\`
      });
    }
    
    // D√©terminer le restaurantId
    let finalRestaurantId = restaurantId;
    if (!finalRestaurantId && req.user.role === 'owner') {
      finalRestaurantId = req.user.restaurantId;
    }
    
    // Valider le restaurant si fourni
    if (finalRestaurantId) {
      const restaurant = await Restaurant.findById(finalRestaurantId);
      if (!restaurant) {
        return res.status(400).json({
          success: false,
          message: 'Restaurant sp√©cifi√© non trouv√©'
        });
      }
    }
    
    // Hasher le mot de passe
    const saltRounds = 12;
    const hashedPassword = await bcrypt.hash(password, saltRounds);
    
    const newUser = new User({
      firstName,
      lastName,
      email,
      password: hashedPassword,
      role,
      phone,
      restaurantId: finalRestaurantId || null,
      isActive: true,
      timestamps: {
        createdAt: new Date(),
        updatedAt: new Date()
      }
    });
    
    const savedUser = await newUser.save();
    await savedUser.populate('restaurantId', 'name address.city');
    
    // Retourner sans le mot de passe
    const userResponse = savedUser.toObject();
    delete userResponse.password;
    
    console.log('User cr√©√©:', savedUser.email, 'r√¥le:', savedUser.role);
    
    res.status(201).json({
      success: true,
      message: 'Utilisateur cr√©√© avec succ√®s',
      data: { user: userResponse }
    });
    
  } catch (error) {
    console.error('Erreur createUser:', error);
    res.status(500).json({
      success: false,
      message: 'Erreur lors de la cr√©ation de l\\'utilisateur',
      error: process.env.NODE_ENV === 'development' ? error.message : undefined
    });
  }
};

/**
 * Mettre √† jour un utilisateur
 * PUT /users/:id
 */
exports.updateUser = async (req, res) => {
  try {
    const { id } = req.params;
    console.log('updateUser appel√© pour ID:', id, 'par:', req.user?.email);
    
    const user = await User.findById(id);
    
    if (!user) {
      return res.status(404).json({
        success: false,
        message: 'Utilisateur non trouv√©'
      });
    }
    
    // V√©rification permissions
    const canUpdate = req.user.role === 'admin' ||
                     (req.user.role === 'owner' && user.restaurantId?.toString() === req.user.restaurantId?.toString()) ||
                     (req.user._id.toString() === id);
    
    if (!canUpdate) {
      return res.status(403).json({
        success: false,
        message: 'Acc√®s non autoris√©'
      });
    }
    
    const updateData = { ...req.body };
    delete updateData._id;
    delete updateData.__v;
    delete updateData.password; // Le mot de passe se change via une route d√©di√©e
    
    // Mise √† jour timestamp
    updateData.timestamps = {
      ...user.timestamps,
      updatedAt: new Date()
    };
    
    const updatedUser = await User.findByIdAndUpdate(
      id,
      updateData,
      { new: true, runValidators: true }
    ).populate('restaurantId', 'name address.city').select('-password');
    
    console.log('User mis √† jour:', updatedUser.email);
    
    res.json({
      success: true,
      message: 'Utilisateur mis √† jour avec succ√®s',
      data: { user: updatedUser }
    });
    
  } catch (error) {
    console.error('Erreur updateUser:', error);
    res.status(500).json({
      success: false,
      message: 'Erreur lors de la mise √† jour de l\\'utilisateur',
      error: process.env.NODE_ENV === 'development' ? error.message : undefined
    });
  }
};

/**
 * Supprimer un utilisateur
 * DELETE /users/:id
 */
exports.deleteUser = async (req, res) => {
  try {
    const { id } = req.params;
    console.log('deleteUser appel√© pour ID:', id, 'par:', req.user?.email);
    
    // V√©rification permissions - Seul admin peut supprimer
    if (req.user.role !== 'admin') {
      return res.status(403).json({
        success: false,
        message: 'Acc√®s non autoris√© - Admin requis'
      });
    }
    
    const user = await User.findById(id);
    
    if (!user) {
      return res.status(404).json({
        success: false,
        message: 'Utilisateur non trouv√©'
      });
    }
    
    // Emp√™cher la suppression de soi-m√™me
    if (req.user._id.toString() === id) {
      return res.status(400).json({
        success: false,
        message: 'Impossible de supprimer votre propre compte'
      });
    }
    
    await User.findByIdAndDelete(id);
    
    console.log('User supprim√©:', user.email);
    
    res.json({
      success: true,
      message: 'Utilisateur supprim√© avec succ√®s'
    });
    
  } catch (error) {
    console.error('Erreur deleteUser:', error);
    res.status(500).json({
      success: false,
      message: 'Erreur lors de la suppression de l\\'utilisateur',
      error: process.env.NODE_ENV === 'development' ? error.message : undefined
    });
  }
};

module.exports = exports;
`;

  createFile(userControllerPath, userControllerCode, 'UserController');
};

// === CR√âATION UTILITAIRE PAGINATION ===
const createPaginationUtil = () => {
  console.log('\nüìÑ 3. V√©rification utilitaire pagination');
  
  const utilsDir = path.join(__dirname, 'src', 'utils');
  const paginationPath = path.join(utilsDir, 'pagination.js');
  
  if (!fs.existsSync(paginationPath)) {
    ensureDirectory(utilsDir);
    
    const paginationCode = `/**
 * Utilitaire de pagination Zengest
 * G√©n√©r√© automatiquement
 */

/**
 * Cr√©er un objet de pagination standardis√©
 * @param {number} page - Page actuelle  
 * @param {number} limit - √âl√©ments par page
 * @param {number} total - Total d'√©l√©ments
 * @returns {Object} Objet pagination
 */
const createPagination = (page, limit, total) => {
  const currentPage = parseInt(page) || 1;
  const itemsPerPage = Math.min(parseInt(limit) || 10, 100);
  const totalItems = parseInt(total) || 0;
  const totalPages = Math.ceil(totalItems / itemsPerPage);

  return {
    currentPage,
    totalPages,
    total: totalItems,
    limit: itemsPerPage,
    hasNextPage: currentPage < totalPages,
    hasPrevPage: currentPage > 1,
    nextPage: currentPage < totalPages ? currentPage + 1 : null,
    prevPage: currentPage > 1 ? currentPage - 1 : null,
    skip: (currentPage - 1) * itemsPerPage
  };
};

/**
 * Middleware pour valider les param√®tres de pagination
 */
const validatePagination = (req, res, next) => {
  const { page = 1, limit = 10 } = req.query;
  
  const pageNum = parseInt(page);
  const limitNum = parseInt(limit);
  
  if (isNaN(pageNum) || pageNum < 1) {
    return res.status(400).json({
      success: false,
      message: 'Le num√©ro de page doit √™tre un entier positif'
    });
  }
  
  if (isNaN(limitNum) || limitNum < 1 || limitNum > 100) {
    return res.status(400).json({
      success: false,
      message: 'La limite doit √™tre entre 1 et 100'
    });
  }
  
  req.pagination = {
    page: pageNum,
    limit: limitNum,
    skip: (pageNum - 1) * limitNum
  };
  
  next();
};

module.exports = {
  createPagination,
  validatePagination
};
`;

    createFile(paginationPath, paginationCode, 'Utilitaire pagination');
  } else {
    console.log('   ‚úÖ Utilitaire pagination d√©j√† pr√©sent');
  }
};

// === EX√âCUTION ===
const runCreation = () => {
  console.log('üöÄ Cr√©ation des fichiers manquants...\n');
  
  // V√©rification pr√©requis
  if (!fs.existsSync(path.join(__dirname, 'package.json'))) {
    console.error('‚ùå Ex√©cutez ce script depuis la racine du projet Zengest');
    process.exit(1);
  }
  
  // Cr√©er les contr√¥leurs manquants
  createRestaurantController();
  createUserController();
  createPaginationUtil();
  
  // Rapport final
  console.log('\n' + '='.repeat(50));
  console.log('üìä RAPPORT DE CR√âATION');
  console.log('='.repeat(50));
  console.log(`‚úÖ Fichiers cr√©√©s: ${filesCreated}`);
  
  console.log('\nüìã FICHIERS G√âN√âR√âS:');
  console.log('‚Ä¢ src/controllers/restaurantController.js - Gestion restaurants compl√®te');
  console.log('‚Ä¢ src/controllers/userController.js - Gestion utilisateurs avec pagination');
  console.log('‚Ä¢ src/utils/pagination.js - Utilitaire pagination (si manquant)');
  
  console.log('\nüéØ FONCTIONNALIT√âS INCLUSES:');
  console.log('RestaurantController:');
  console.log('  ‚Ä¢ getAllRestaurants, getRestaurant, getRestaurantStatus');
  console.log('  ‚Ä¢ createRestaurant, updateRestaurant, deleteRestaurant');
  console.log('  ‚Ä¢ Permissions par r√¥le, calcul statut temps r√©el');
  
  console.log('UserController:');
  console.log('  ‚Ä¢ getAllUsers, getUser, createUser, updateUser, deleteUser');
  console.log('  ‚Ä¢ Pagination compl√®te, validation r√¥les, permissions');
  console.log('  ‚Ä¢ Gestion restaurantId optionnelle');
  
  console.log('\nüöÄ PROCHAINES √âTAPES:');
  console.log('1. üîÑ Red√©marrez le serveur: npm run dev');
  console.log('2. üß™ Testez: node post-corrections.js');
  console.log('3. üìà V√©rifiez le nouveau taux (attendu: 90%+)');
  console.log('4. üéâ Test complet: node test-complete-zengest.js');
  
  if (filesCreated >= 2) {
    console.log('\nüéâ SUCC√àS! Contr√¥leurs critiques cr√©√©s');
    console.log('üí° Les erreurs 403 et "m√©thodes manquantes" devraient √™tre r√©solues');
    console.log('üöÄ Votre backend devrait maintenant atteindre 90%+ de r√©ussite!');
  } else {
    console.log('\n‚ö†Ô∏è Cr√©ation partielle. V√©rifiez les erreurs ci-dessus');
  }
  
  console.log(`\n‚è∞ Cr√©ation termin√©e √† ${new Date().toLocaleTimeString()}`);
  console.log('üîß Contr√¥leurs professionnels avec toutes les fonctionnalit√©s!');
};

// Lancer la cr√©ation
runCreation();